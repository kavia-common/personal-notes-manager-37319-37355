---
/**
 * PUBLIC_INTERFACE
 * NotesList.astro
 * Renders a list/grid of notes with search, filtering, pagination.
 * Props:
 *  - view: 'list' | 'grid'
 *  - filter: 'all' | 'favorites'
 *  - tag?: string
 */
import type { Note, APIError, Paginated } from '../lib/types';
import { NotesStore } from '../lib/store';

const { view = 'list', filter = 'all', tag } = Astro.props as {
  view?: 'list' | 'grid',
  filter?: 'all' | 'favorites',
  tag?: string
};
---

<section class="card" style="padding: 16px;" aria-labelledby="notes-heading">
  <h2 id="notes-heading" class="visually-hidden">Notes list</h2>

  <div style="display:flex;gap:12px;align-items:center;margin-bottom:12px;flex-wrap:wrap;">
    <label class="visually-hidden" for="search-input">Search notes</label>
    <input id="search-input" class="input" style="max-width:420px;" type="search" placeholder="Search notes..." aria-label="Search notes" />
    <div class="text-muted" style="font-size:14px;">Filter: {filter}</div>
  </div>

  <div id="notes-state" class="text-muted" role="status" aria-live="polite" style="display:none;margin: 12px 0;">Loading notes…</div>

  <div id="skeleton-list" aria-hidden="true" style={`display:grid; grid-template-columns: ${view === 'grid' ? 'repeat(auto-fill, minmax(260px, 1fr))' : '1fr'}; gap:12px;`}>
    {Array.from({ length: 6 }).map(() => (
      <div class="card note-card skeleton">
        <div class="sk-title"></div>
        <div class="sk-line"></div>
        <div class="sk-line short"></div>
      </div>
    ))}
  </div>

  <div id="notes-list"
    style={`display: none; grid-template-columns: ${view === 'grid' ? 'repeat(auto-fill, minmax(260px, 1fr))' : '1fr'}; gap: 12px;`}
    aria-live="polite"
    role="list"
  >
    <!-- Client script populates list -->
  </div>

  <div id="pagination" style="display:flex; justify-content: space-between; align-items:center; margin-top: 12px;">
    <button class="btn" id="prev-page" disabled aria-label="Previous page">Previous</button>
    <span class="text-muted" id="page-info" style="font-size: 14px;" role="status" aria-live="polite"></span>
    <button class="btn" id="next-page" disabled aria-label="Next page">Next</button>
  </div>
</section>

<style>
  .note-card {
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .note-card:focus-within {
    outline: 2px solid color-mix(in oklab, var(--color-primary), transparent 40%);
    outline-offset: 2px;
    border-radius: var(--radius-md);
  }
  .skeleton {
    overflow: hidden;
    position: relative;
  }
  .skeleton::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, transparent, color-mix(in oklab, #ccc, transparent 60%), transparent);
    transform: translateX(-100%);
    animation: shimmer 1.2s infinite;
  }
  .sk-title, .sk-line {
    height: 12px;
    background: color-mix(in oklab, #ccc, transparent 40%);
    border-radius: 6px;
    margin: 8px 0;
  }
  .sk-title { width: 60%; height: 16px; margin-top: 0; }
  .sk-line.short { width: 40%; }
  @keyframes shimmer {
    100% { transform: translateX(100%); }
  }
  .fade-in {
    animation: fadeIn .15s ease;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(2px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .note-title {
    margin: 0;
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 700;
  }
  .note-actions {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-end;
  }
  .favorite {
    border-color: color-mix(in oklab, var(--color-secondary), transparent 60%);
    color: var(--color-secondary-600);
  }
</style>

<script type="module">
  import { NotesStore } from '../lib/store.ts';

  const params = new URLSearchParams(window.location.search);
  const initialFilter = params.get('filter') || (Astro.props?.filter ?? 'all');
  const tag = params.get('tag') || (Astro.props?.tag ?? undefined);

  const elList = document.getElementById('notes-list');
  const elState = document.getElementById('notes-state');
  const elSearch = document.getElementById('search-input');
  const elPrev = document.getElementById('prev-page');
  const elNext = document.getElementById('next-page');
  const elPageInfo = document.getElementById('page-info');
  const elSkeleton = document.getElementById('skeleton-list');

  let page = Number(params.get('page') || 1);
  const pageSize = 12;
  let search = params.get('q') || '';

  if (elSearch) elSearch.value = search;

  function setState(msg) {
    if (!elState) return;
    elState.style.display = msg ? 'block' : 'none';
    elState.textContent = msg || '';
  }

  function toast(type, message) {
    window.dispatchEvent(new CustomEvent('toast', { detail: { type, message }}));
  }

  function noteCardHTML(n) {
    const favClass = n.favorite ? 'favorite' : '';
    return `
      <article class="card note-card fade-in" data-id="${n.id}" role="listitem" aria-labelledby="title-${n.id}">
        <h3 class="note-title" id="title-${n.id}">
          <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${n.title || '(Untitled)'}</span>
          <button class="btn ${favClass} btn-fav" aria-label="${n.favorite ? 'Unfavorite note' : 'Favorite note'}" title="${n.favorite ? 'Unfavorite' : 'Favorite'}" aria-pressed="${n.favorite ? 'true' : 'false'}">
            ${n.favorite ? '★' : '☆'}
          </button>
        </h3>
        <p class="text-muted" style="margin:0 0 8px; overflow:hidden; display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical;">${(n.content || '').replace(/</g,'&lt;').slice(0,300)}</p>
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <span class="text-muted" style="font-size:12px;">Updated ${new Date(n.updatedAt).toLocaleString()}</span>
          <div class="note-actions">
            <a class="btn" style="border-color: var(--color-border);" href="/notes/${encodeURIComponent(n.id)}" aria-label="Open note ${n.title || n.id}">Open</a>
            <a class="btn" style="border-color: var(--color-border);" href="/notes/${encodeURIComponent(n.id)}?edit=1" aria-label="Edit note ${n.title || n.id}">Edit</a>
            <button class="btn btn-delete" data-id="${n.id}" aria-label="Delete note ${n.title || n.id}">Delete</button>
          </div>
        </div>
      </article>
    `;
  }

  function renderList(paginated) {
    if (!elList) return;
    if (!paginated.items?.length) {
      elList.innerHTML = `<div class="text-muted">No notes found.</div>`;
    } else {
      elList.innerHTML = paginated.items.map(noteCardHTML).join('');
    }

    // Show list, hide skeleton
    if (elSkeleton) elSkeleton.style.display = 'none';
    elList.style.display = 'grid';

    const totalPages = Math.max(1, Math.ceil((paginated.total || 0) / (paginated.pageSize || pageSize)));
    elPrev.disabled = page <= 1;
    elNext.disabled = page >= totalPages;
    elPageInfo.textContent = `Page ${page} of ${totalPages} • ${paginated.total} total`;

    // focus first "Open" button for keyboard users after render
    const firstOpen = elList.querySelector('a[href*="/notes/"]');
    if (firstOpen && document.activeElement === elSearch) {
      // Keep focus on search if user is typing; otherwise focus first item
    } else if (firstOpen) {
      (firstOpen as HTMLElement).focus({ preventScroll: false });
    }

    // Handlers
    elList.querySelectorAll('.btn-fav').forEach(btn => {
      btn.addEventListener('click', async (ev) => {
        const article = ev.currentTarget.closest('article');
        if (!article) return;
        const id = article.getAttribute('data-id');
        const starBtn = ev.currentTarget;
        const currentFav = starBtn.getAttribute('aria-pressed') === 'true';
        // optimistic UI immediately; store handles rollback if needed
        starBtn.setAttribute('aria-pressed', (!currentFav).toString());
        starBtn.textContent = currentFav ? '☆' : '★';
        starBtn.classList.toggle('favorite', !currentFav);
        try {
          await NotesStore.toggleFavorite(id);
          toast('success', `Note ${!currentFav ? 'favorited' : 'unfavorited'}.`);
        } catch (e) {
          // rollback UI
          starBtn.setAttribute('aria-pressed', currentFav.toString());
          starBtn.textContent = currentFav ? '★' : '☆';
          starBtn.classList.toggle('favorite', currentFav);
          toast('error', e?.message || 'Failed to update favorite');
        }
      });
    });

    elList.querySelectorAll('.btn-delete').forEach(btn => {
      btn.addEventListener('click', async (ev) => {
        const id = ev.currentTarget.getAttribute('data-id');
        if (!id) return;

        const ask = () => new Promise<boolean>((resolve) => {
          // prefer custom dialog if present
          const useDialog = typeof window !== 'undefined';
          if (useDialog) {
            window.dispatchEvent(new CustomEvent('confirm-dialog', {
              detail: {
                title: 'Delete note?',
                message: 'This action cannot be undone.',
                confirmLabel: 'Delete',
                cancelLabel: 'Cancel',
                onConfirm: () => resolve(true),
              }
            }));
            // Fallback: if dialog not mounted, fallback to confirm
            setTimeout(() => resolve(window.confirm('Delete this note? This cannot be undone.')), 50);
          } else {
            resolve(true);
          }
        });

        const confirmed = await ask();
        if (!confirmed) return;

        const node = elList.querySelector(`article[data-id="${CSS.escape(id)}"]`);
        const previousHTML = node?.outerHTML;
        node?.remove();

        try {
          await NotesStore.remove(id);
          toast('success', 'Note deleted.');
          // refresh list to maintain pagination integrity
          load();
        } catch (e) {
          if (previousHTML && elList) {
            elList.insertAdjacentHTML('afterbegin', previousHTML);
          }
          toast('error', e?.message || 'Failed to delete note');
        }
      });
    });
  }

  async function load() {
    // Abort any in-flight requests before starting a new one
    NotesStore.cancelInFlight();

    if (elSkeleton) elSkeleton.style.display = 'grid';
    if (elList) elList.style.display = 'none';
    setState('Loading notes…');
    try {
      const resp = await NotesStore.loadList({
        page, pageSize,
        search: search || undefined,
        favorite: initialFilter === 'favorites' ? true : undefined,
        tag: tag || undefined
      });
      renderList(resp);
      setState('');
    } catch (e) {
      // Hide skeleton on error
      if (elSkeleton) elSkeleton.style.display = 'none';
      if (elList) {
        elList.style.display = 'grid';
        elList.innerHTML = `<div role="alert" class="text-muted">We couldn’t load your notes. Please try again.</div>`;
      }
      setState('');
      toast('error', e?.message || 'Failed to load notes');
    }
  }

  // pagination
  elPrev?.addEventListener('click', () => {
    if (page > 1) {
      page -= 1;
      load();
    }
  });
  elNext?.addEventListener('click', () => {
    page += 1;
    load();
  });
  elSearch?.addEventListener('change', () => {
    page = 1;
    search = elSearch.value.trim();
    const url = new URL(window.location.href);
    if (search) url.searchParams.set('q', search); else url.searchParams.delete('q');
    history.replaceState(null, '', url.toString());
    // invalidate cache so new search re-fetches
    NotesStore.invalidateList(true);
    load();
  });

  // subscribe for external invalidations
  const unsub = NotesStore.subscribe(() => {
    const s = NotesStore.getState();
    if (s.list && s.listParams) {
      renderList(s.list);
    }
  });

  window.addEventListener('beforeunload', unsub);

  load();
</script>
